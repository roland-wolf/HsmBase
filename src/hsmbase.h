/*
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/



#ifndef HSMBASE_H
#define HSMBASE_H

namespace stm
{

struct DefaultConfig
{
    const static int MAXDEPTH = 10;
    const static int ENTRIES = 50;
    static void assertFunc()
    {
        //assert(0);
    }
};



/**
* This class provides the plumbing for a state machine implementation where a state is associated with a method
* Use this class with CRTP: class MyStateMachine : public StateProcessor<MyStateMachine, Event>
*/
template <typename Derived, typename EventType , typename ArraySize = DefaultConfig>
class HsmBase
{
public:
    HsmBase()
        : m_nextIndex(2)  //2 places reserved for root and superroot
        , m_reason(INIT)
        , m_transitionSeen(false)
        , m_rootSet(false)
        , m_state(0)
        , m_started(false)
    {
        m_nodes[1].hierarchy=0;
        m_derivedThis = static_cast<Derived *>(this);
    }

    virtual ~HsmBase(){}

    typedef void(Derived::*DerivedMethod)(const EventType *);

    enum Reason {INIT, ENTRY, EXIT, ROUTE, ACTION };

    class Node {
    public:
        Node(DerivedMethod derivedMeth_): derivedMeth(derivedMeth_), initTarget(0) {}
        Node(): derivedMeth(0), initTarget(0) { }

        Node *parent;
        int hierarchy;
        DerivedMethod derivedMeth;
        Node *initTarget;
    };

    void processEvent(const EventType *event);
    void writeTrace(DerivedMethod targetState);  //from current State to target Trace
    void start();
    void setRoot(DerivedMethod meth);
    int stateId(){return m_state;}

    void initStatemachine(DerivedMethod target, DerivedMethod initialMethod =0);


    void terminate(){  m_started= false;  }

    void dummy(const EventType *ev){}

    bool addInit(DerivedMethod meth, DerivedMethod target);
    int methodToIndex(DerivedMethod meth);
    int addChildState(DerivedMethod parentMeth, DerivedMethod child);

protected:
    const Reason reason()  {   return m_reason;  }
    void transition(DerivedMethod meth);
    void handled()    {  m_handled = true;  }

private:

    void writeInitTrace(int root, int target);
    void processInits(Node *node, const EventType *event);
    void callInits(Node *currentNode, const EventType *ev);

    struct Nodes{
        int nodes[ArraySize::MAXDEPTH];
        int nextIndex;
        void addElement(int node){
            nodes[nextIndex]= node;
            nextIndex++;
        }
        void clear(){
            nextIndex=0;
        }
        int last(){
            if(nextIndex > 0){
                nodes[nextIndex-1];
                return -1;
            }else{
                return -1;
            }
        }
    };



    int find(DerivedMethod method);

    ///TODO intialize all members in constructor
    int m_state;  //index of current state ->m_nodes
    //Node *m_transitionFrom;
    Nodes m_up;
    Nodes m_down;
    Node *m_callNode;
    Nodes m_initNodes;
    Reason m_reason;
    Node m_nodes[ArraySize::ENTRIES+2]; //need space also for root and super root
    Node m_transitionRoot;
    int m_nextIndex;
    int m_targetIndex;
    bool m_transitionSeen;
    bool m_handled;
    bool m_rootSet;
    bool m_started;
    Derived *m_derivedThis;
};


//---------------------------implementation-------------------------
//------------------------------------------------------------------

template <typename Derived, typename EventType, typename ArraySize>
void HsmBase<Derived, EventType, ArraySize>::callInits(Node *currentNode, const EventType *ev)
{
    m_reason = INIT;
    while(currentNode->initTarget !=0){
        (currentNode->derivedMeth)(ev);
        currentNode=currentNode->initTarget;
    }
}


template <typename Derived, typename EventType, typename ArraySize>
void HsmBase<Derived, EventType, ArraySize>::transition(DerivedMethod meth)
{
    m_transitionSeen = true;
    int targetState = methodToIndex(meth);
    writeTrace(meth);
    m_state = targetState;
}



template <typename Derived, typename EventType, typename ArraySize>
void HsmBase<Derived, EventType, ArraySize>::setRoot(DerivedMethod meth)
{
    m_nodes[1].derivedMeth=meth;
    m_rootSet=true;
}


template <typename Derived, typename EventType, typename ArraySize>
bool HsmBase<Derived, EventType, ArraySize>::addInit(DerivedMethod meth, DerivedMethod target)
{
    int index = find(meth);
    int targetIndex = find(target);
    if( (index >=0) && (targetIndex >=0)){
        m_nodes[index].initTarget = &m_nodes[targetIndex];
        return true;
    }
    return false;
}

template <typename Derived, typename EventType, typename ArraySize>
int HsmBase<Derived, EventType, ArraySize>::methodToIndex(DerivedMethod meth)
{
    for(int i=0; i< m_nextIndex; i++){
        if(m_nodes[i].derivedMeth == meth){
            return i;
        }
    }
    DefaultConfig::assertFunc();   //initial state was not registered
    return -1;
}


template <typename Derived, typename EventType, typename ArraySize>
void HsmBase<Derived, EventType, ArraySize>::initStatemachine(DerivedMethod target, DerivedMethod initialMethod)
{
    m_state=methodToIndex(target);
    Node &superRoot = m_nodes[0];
    m_nodes[1].parent = &m_nodes[0];
    superRoot.initTarget = &m_nodes[m_state] ;
    if(initialMethod ==0){
        superRoot.derivedMeth = &Derived::dummy;
    }else{
        superRoot.derivedMeth = initialMethod;
    }
}


template <typename Derived, typename EventType, typename ArraySize>
void HsmBase<Derived, EventType, ArraySize>::start()
{
    if(!m_rootSet){
        return;
    }
    m_started = true;
    EventType event;  //serves as dummy argument
    Node &superRoot = m_nodes[0];
    //superRoot.derived Method always != 0, either user supplied or dummyMethod
    m_callNode = &m_nodes[0];
    processInits(&superRoot, &event);
}


template <typename Derived, typename EventType, typename ArraySize>
int HsmBase<Derived, EventType, ArraySize>::find(DerivedMethod method){

    bool found = false;
    for(int i=0; i< m_nextIndex; i++)
    {
        if(m_nodes[i].derivedMeth == method){
            found = true;
            return i;
        }
    }
    return  -1;
}

template <typename Derived, typename EventType, typename ArraySize>
void HsmBase<Derived, EventType, ArraySize>::writeInitTrace(int root, int target)
{
    m_initNodes.clear();
    while(root != target){
        m_initNodes.addElement(target);
        target = m_nodes[target].parent - m_nodes;
    }
}

template <typename Derived, typename EventType, typename ArraySize>
void HsmBase<Derived, EventType, ArraySize>::writeTrace(DerivedMethod targetState)  //from current State to top
{
    m_up.nextIndex = 0;
    m_down.nextIndex = 0;
    //find source and target state in pool
    m_targetIndex = find(targetState);
    if(m_targetIndex < 0){
        DefaultConfig::assertFunc();
        return;
    }
    Node *targetNode = &m_nodes[m_targetIndex];

    Node *sourceNode = &m_nodes[m_state];

    int targetDeeper = targetNode->hierarchy - sourceNode->hierarchy;

    Nodes *nodes= &m_up;
    Node *deeperNode = sourceNode;
    Node *otherNode = targetNode;
    bool isTargetDeeper=true;
    bool swapped = false;
    if(targetDeeper>0){
        nodes= &m_down;
        deeperNode = targetNode;
        otherNode = sourceNode;
        swapped=true;
    }else{
        isTargetDeeper = false;
        targetDeeper = -targetDeeper;
    }
    bool transitionSourceMet = false;
    for(int i=0; i<targetDeeper  ; i++ ){
        transitionSourceMet = transitionSourceMet
                || (m_callNode == deeperNode  );
        nodes->addElement(deeperNode - m_nodes);
        deeperNode = deeperNode->parent;
    }


    const int depth = deeperNode->hierarchy;
    if(swapped){
        //swap back
        Node *temp = deeperNode;
        deeperNode = otherNode;
        otherNode = temp;
    }
    bool selfTransition = (targetState == m_callNode->derivedMeth);

    bool upMetDown = false;
    for(int i=0; i< depth; i++){
        upMetDown = upMetDown || (deeperNode->derivedMeth == otherNode->derivedMeth);
        transitionSourceMet = transitionSourceMet
                || (m_callNode == deeperNode  )
                || (m_callNode == otherNode);
        if(transitionSourceMet
                && (deeperNode->derivedMeth == otherNode->derivedMeth)
                && (!selfTransition) ){
            break;
        }
        m_up.addElement(deeperNode - m_nodes);
        m_down.addElement(otherNode - m_nodes);
        deeperNode = deeperNode->parent;
        otherNode = otherNode->parent;
        if(upMetDown && transitionSourceMet){
            break;
        }
    }
    if(deeperNode->derivedMeth != otherNode->derivedMeth){
        DefaultConfig::assertFunc();
        return;
    }
    m_transitionRoot = *deeperNode;
}


template <typename Derived, typename EventType, typename ArraySize>
int HsmBase<Derived, EventType, ArraySize>::addChildState(DerivedMethod parentMeth, DerivedMethod child)
{
    if(m_nextIndex > ArraySize::ENTRIES){
        DefaultConfig::assertFunc();
        return false;
    }
    ///@TODO ASSERT on duplicate calls
    int i =0;
    bool success= false;
    for(; i< m_nextIndex; i++){
        if(m_nodes[i].derivedMeth == parentMeth){
            m_nodes[m_nextIndex].derivedMeth= child;
            m_nodes[m_nextIndex].parent = &m_nodes[i];
            m_nodes[m_nextIndex].hierarchy = m_nodes[i].hierarchy+1;
            success = true;
            break;
        }
    }
    if(success){
        int stateId = m_nextIndex;
        m_nextIndex++;
        return stateId;
    }
    return -1;
}

template <typename Derived, typename EventType, typename ArraySize>
void HsmBase<Derived, EventType, ArraySize>::processEvent(const EventType *event)
{
    if(!m_started){
        return;
    }
    m_transitionSeen = false;
    m_handled = false;



    //Query state, if no transition query all parent states
    this->m_reason = ROUTE;
    for(m_callNode = &m_nodes[m_state]; m_callNode->hierarchy >=0; m_callNode = m_callNode->parent ){
        // m_callNode;  //will be needed when transition is called to have the bubble where the arrow originated
        (m_derivedThis->*(m_callNode->derivedMeth))(event);
        if(m_transitionSeen){
            break;
        }
        if(m_handled){
            return;
        }
    }
    if(m_transitionSeen == false){
        return;
    }
    m_reason = EXIT;
    for(int i=0; i<m_up.nextIndex; i++){
        (m_derivedThis->*(m_nodes[m_up.nodes[i]].derivedMeth))(event);
    }
    m_reason = ACTION;
    (m_derivedThis->*(m_nodes[m_up.nodes[0]].derivedMeth))(event);

    m_reason = ENTRY;
    for(int i=m_down.nextIndex -1; i>=0; i--){
        (m_derivedThis->*(m_nodes[m_down.nodes[i]].derivedMeth))(event);
    }

    Node *node = &m_nodes[m_targetIndex];
    processInits(node, event);
}

template <typename Derived, typename EventType, typename ArraySize>
void HsmBase<Derived, EventType, ArraySize>::processInits(Node *node, const EventType *event)
{
    while(node->initTarget !=0){
        m_reason= INIT;
        (m_derivedThis->*(node->derivedMeth))(event);
        writeInitTrace(node - m_nodes  , node->initTarget - m_nodes);
        m_reason= ENTRY;
        for(int i=m_initNodes.nextIndex-1; i>=0 ; i--){
            (m_derivedThis->*(m_nodes[m_initNodes.nodes[i]].derivedMeth))(event);
        }
        m_state = node->initTarget - &m_nodes[0];
        node= node->initTarget;
    }
}

} //namespace stm

#endif // HSMBASE_H
